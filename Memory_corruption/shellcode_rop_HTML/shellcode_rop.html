<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>shellcode_rop</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><h1><b><u>shellcode_rop</u></b></h1><span style="background-color:#ffc0cb;">Writing shellcode: </span><a href="https://www.exploit-db.com/papers/13224">https://www.exploit-db.com/papers/13224</a><br /><span style="background-color:#ffc0cb;">Vulnerable machine: </span><a href="https://www.vulnhub.com/entry/rop-primer-02,114/">https://www.vulnhub.com/entry/rop-primer-02,114/</a><span style="background-color:#ffc0cb;"><br />Blogs which i learned from: </span><a href="https://g0blin.co.uk/rop-primer-0-2-vulnhub-writeup/">https://g0blin.co.uk/rop-primer-0-2-vulnhub-writeup/</a><br /><img src="images/24-1.png" alt="images/24-1.png" /><br /><br /><span style="background-color:#ffff00;">Before working on ROP, we proceed to test shellcode with this:</span><br /><img src="images/24-2.png" alt="images/24-2.png" /><br /><br /><span style="background-color:#ffff00;">What is essentially done is we taking the shellcode and testing it in this C code<br />Why there is a need for -z execstack is because if that flag isn't present the executable will crash due to the<br />fact that the machine cant execute code from memory due to memory having NX active.</span><br /><img src="images/24-3.png" alt="images/24-3.png" /><br /><br /><span style="background-color:#ffff00;">If the stack is active, it will be displayed as RED with rwxp</span><br /><img src="images/24-4.png" alt="images/24-4.png" /><br /><br /><span style="background-color:#ffff00;">When we execute test, it pops a shell, now that our shellcode is sorted we can proceed<br />to exploit the vulnerable program</span><br /><img src="images/24-5.png" alt="images/24-5.png" /><br /><br /><span style="background-color:#ffff00;">Checking the program, it has NX enabled and it means that the stack area of the memory is non-executable</span><br /><img src="images/24-6.png" alt="images/24-6.png" /><br /><br /><span style="background-color:#ffff00;">Setting the breakpoint when the program starts, lets inspect the memory mappings when we run the program</span><br /><img src="images/24-7.png" alt="images/24-7.png" /><br /><img src="images/24-8.png" alt="images/24-8.png" /><br />    <br /><span style="background-color:#ffff00;">Stack is only read and write as evidenced by rw-p</span><br /><img src="images/24-9.png" alt="images/24-9.png" /><br /><br /><span style="background-color:#ffa500;">Lets crash the program and see what happens</span><br /><br /><span style="background-color:#ffff00;">Generating predictable string so we can know the offset, offset is just located 4 bytes before the register EIP</span><br /><img src="images/24-10.png" alt="images/24-10.png" /><br /><img src="images/24-11.png" alt="images/24-11.png" /><br /><br /><span style="background-color:#ffff00;">Program crashed because when we overwrite EIP with random values, program doesn't know where to return to</span><br /><img src="images/24-12.png" alt="images/24-12.png" /><br /><br /><span style="background-color:#ffff00;">Lets find where in the stack this 0x41414641 is</span><br /><img src="images/24-13.png" alt="images/24-13.png" /><br /><img src="images/24-14.png" alt="images/24-14.png" /><br /><br /><span style="background-color:#ffff00;">0x41414641 is just before the ESP register, </span><br /><img src="images/24-15.png" alt="images/24-15.png" /><br /><img src="images/24-16.png" alt="images/24-16.png" /><br /><br /><span style="background-color:#ffff00;">So we have overwritten the EIP with 0x41414641, but thing is we need to know the offset which is how long we <br />have to write with random values before we overwrite EIP with our `custom values`</span><br /><img src="images/24-17.png" alt="images/24-17.png" /><br /><br /><span style="background-color:#ffff00;">Lets create a custom python file so we can actually put all of this into action</span><br /><img src="images/24-18.png" alt="images/24-18.png" /><br /><br /><span style="background-color:#ffff00;">We run the exploit so we can create a text file to be used in the debugger later</span><br /><img src="images/24-19.png" alt="images/24-19.png" /><br /><br /><span style="background-color:#ffff00;">This is proof that we have control of the values in the EIP and it means that we can manipulate the program to redirect<br />code execution</span><br /><img src="images/24-20.png" alt="images/24-20.png" /><br /><br /><span style="background-color:#ffa500;">To disable NX we need to search for this mprotect function</span><br /><br /><a href="https://failingsilently.wordpress.com/2017/12/17/rop-exploit-mprotect-and-shellcode/">https://failingsilently.wordpress.com/2017/12/17/rop-exploit-mprotect-and-shellcode/</a><br /><img src="images/24-21.png" alt="images/24-21.png" /><br /><br /><span style="background-color:#ffff00;">Confirming what previous author said in: </span><a href="https://syscalls.kernelgrok.com/">https://syscalls.kernelgrok.com/</a><span style="background-color:#ffff00;"><br />This is useful for ROP without return to libc but at the moment what we need to know is<br />EBX - First parameter<br />ECX - Second parameter<br />EDX - Third parameter</span><br /><img src="images/24-22.png" alt="images/24-22.png" /><br /><br /><span style="background-color:#ffff00;">To get the parameters, we run info proc mappings command</span><br /><img src="images/24-23.png" alt="images/24-23.png" /><br /><span style="background-color:#ffff00;">First parameter: 0xbffdf000 -&gt; Start Address of stack<br />Second paramter: 0x21000 -&gt; Size<br />Third parameter: 0x7 -&gt; Read(4),Write(2),Execute(1), 4 + 2 + 1 = 7</span><br /><br /><span style="background-color:#ffff00;">To get the address of mprotect(), we need to run this command in bash</span><br /><span style="background-color:#ffff00;">mprotect() address: 0x080523e0</span><br /><img src="images/24-24.png" alt="images/24-24.png" /><br /><br /><span style="background-color:#ffff00;">So right now we need to plug the address of mprotect(), first parameter, second parameter and third parameter to our code</span><br /><span style="background-color:#ffc0cb;">After plugging in the value we need to intergrate it with our code so that when the program crashed at 0xdeadbeef earlier, we can determine<br />that the stack is indeed executable. <br />Do note the placement of control_eip variable.</span><br /><img src="images/24-25.png" alt="images/24-25.png" /><br /><br /><span style="background-color:#ffff00;">Running our exploit code to generate the text file to be used in the debugger later</span><br /><img src="images/24-26.png" alt="images/24-26.png" /><br /><br /><span style="background-color:#ffff00;">Ran the exploit in the debugger and it crashed</span><br /><img src="images/24-27.png" alt="images/24-27.png" /><br /><br /><span style="background-color:#ffff00;">The interesting this is, the moment it crashed, the stack is executable!</span><br /><span style="background-color:#ffff00;">And this means we can execute our shellcode!</span><br /><img src="images/24-28.png" alt="images/24-28.png" /><br /><br /><span style="background-color:#ffff00;">We can't just plug our shellcode right away, instead we need to change the value of variable control_eip from 0xdeadbeef to pop, pop, pop, ret to <br />clean the stack. It doesn't matter what register we need to pop, the important thing is to get 3 mprotect() parameters off the stack so we can execute our shellcode</span><br /><span style="background-color:#ffc0cb;">pppRET = 0x8048882</span><br /><img src="images/24-29.png" alt="images/24-29.png" /><br /><img src="images/24-30.png" alt="images/24-30.png" /><br /><img src="images/24-31.png" alt="images/24-31.png" /><br /><br /><span style="background-color:#ffff00;">Putting what we said into action, the reason we put 0xbadf00d after disable_mprotect() ROP is to confirm that <br />1. Parameter cleaning is successful<br />2. We still had control over the EIP value</span><br /><img src="images/24-32.png" alt="images/24-32.png" /><br /><br /><span style="background-color:#ffff00;">Now stack is disabled and we still control the EIP value</span><br /><span style="background-color:#ffa500;">Its good that we still have the control over program flow, as for now, we actually need to put a custom value to one of the<br />register and that the value is 0xbadf00d</span><br /><img src="images/24-33.png" alt="images/24-33.png" /><br /><img src="images/24-34.png" alt="images/24-34.png" /><br /><img src="images/24-35.png" alt="images/24-35.png" /><br /><br /><span style="background-color:#ffff00;">Putting our theory to action we will overwrite ESP with 0xbadf00d</span><br /><img src="images/24-36.png" alt="images/24-36.png" /><br /><br /><span style="background-color:#ffff00;">Running exploit in debugger</span><br /><img src="images/24-37.png" alt="images/24-37.png" /><br /><br /><span style="background-color:#ffff00;">Now we have control of values in EIP as well as ESP</span><br /><img src="images/24-38.png" alt="images/24-38.png" /><br /><br /><a href="https://veteransec.com/2018/09/10/32-bit-windows-buffer-overflows-made-easy/">https://veteransec.com/2018/09/10/32-bit-windows-buffer-overflows-made-easy/</a><br /><img src="images/24-39.png" alt="images/24-39.png" /><br /><br /><span style="background-color:#ffff00;">Confirming what the author said above</span><br /><img src="images/24-40.png" alt="images/24-40.png" /><br /><br /><span style="background-color:#ffff00;">Finding JMP ESP in vulnerable binary</span><br /><img src="images/24-41.png" alt="images/24-41.png" /><br /><br /><span style="background-color:#ffa500;">Lets put our theory in action!</span><br /><br /><span style="background-color:#ffff00;">Earlier we had a c program that test our shellcode and so we just need to copy over the hex values located between “”</span><br /><img src="images/24-42.png" alt="images/24-42.png" /><br /><br /><span style="background-color:#ffff00;">Final exploit code!</span><br /><img src="images/24-43.png" alt="images/24-43.png" /><br /><br /><span style="background-color:#ffff00;">Confirmed that code redirection to shell is successful in debugger </span><br /><img src="images/24-44.png" alt="images/24-44.png" /><br /><br /><span style="background-color:#ffff00;">Remember to keep pipe open in cat, else the newly popped shell will close automatically</span><br /><img src="images/24-45.png" alt="images/24-45.png" /><br /><br /><br /><br /><br /><br /><br /><br /><br /></body></html>